<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Show Line-Up Scheduler</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
            color: #333;
            transition: all 0.3s;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s;
        }
        .tab {
            display: none;
        }
        .tab.active {
            display: block;
        }
        .tab-buttons {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .tab-btn {
            padding: 12px 24px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            flex: 1;
            min-width: 100px;
            position: relative;
        }
        .tab-btn.active {
            background-color: #2980b9;
        }
        .tab-btn.error::after {
            content: "‚óè";
            color: red;
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px;
            border: 1px solid #ddd;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
            cursor: pointer;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        textarea, select, input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 16px;
        }
        textarea {
            min-height: 150px;
        }
        input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }
        button {
            padding: 12px 24px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
            width: 100%;
            font-size: 16px;
        }
        button:hover {
            background-color: #27ae60;
        }
        .dynamic-entry {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            align-items: center;
        }
        .dynamic-entry label {
            font-weight: bold;
        }
        .remove-btn {
            background-color: #e74c3c;
            padding: 5px 10px;
            width: auto;
        }
        .remove-btn:hover {
            background-color: #c0392b;
        }
        .error {
            color: red;
            margin: 10px 0;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }
        .roles-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        canvas {
            max-width: 300px;
            margin: 20px auto;
            display: block;
        }
        @media (max-width: 600px) {
            .container { padding: 10px; }
            .tab-btn { padding: 10px; font-size: 14px; }
            th, td { padding: 8px; font-size: 14px; }
            textarea, select, input { font-size: 14px; }
            button { padding: 10px; font-size: 14px; }
            .dynamic-entry { flex-direction: column; }
        }
        .dark-mode {
            background-color: #333;
            color: #fff;
        }
        .dark-mode .container {
            background-color: #444;
            box-shadow: 0 4px 8px rgba(255, 255, 255, 0.1);
        }
        .dark-mode th {
            background-color: #2980b9;
        }
        .dark-mode tr:nth-child(even) {
            background-color: #555;
        }
        .dark-mode textarea, .dark-mode select, .dark-mode input {
            background-color: #555;
            color: #fff;
            border-color: #666;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <h1>Show Line-Up Scheduler</h1>
        <select id="darkModeToggle" onchange="toggleDarkMode()">
            <option value="light">Light Mode</option>
            <option value="dark">Dark Mode</option>
        </select>

        <!-- Tab Buttons -->
        <div class="tab-buttons">
            <button class="tab-btn active" id="artistsTab" onclick="openTab('artists')">Artists</button>
            <button class="tab-btn" id="rolesTab" onclick="openTab('roles')">Roles</button>
            <button class="tab-btn" onclick="openTab('competencies')">Competencies</button>
            <button class="tab-btn" onclick="openTab('conflicts')">Conflicts</button>
            <button class="tab-btn" id="absencesTab" onclick="openTab('absences')">Absences</button>
            <button class="tab-btn" id="lineupTab" onclick="openTab('lineup')">Line-Up</button>
            <button class="tab-btn" onclick="openTab('dashboard')">Dashboard</button>
        </div>

        <!-- Artists Tab -->
        <div id="artists" class="tab active">
            <h2>Artists</h2>
            <p>Add one artist per line: "Name" (e.g., "John")</p>
            <textarea id="artistsInput" placeholder="John\nEmma\nAlex" oninput="validateAndSave('artists')"></textarea>
            <div id="artistsError" class="error"></div>
            <button onclick="exportCSV('artists')">Export Artists to CSV</button>
            <input type="file" id="artistsFile" accept=".csv" onchange="importCSV('artists')">
        </div>

        <!-- Roles Tab -->
        <div id="roles" class="tab">
            <h2>Roles</h2>
            <p>Add one role per line: "Name,Count" (e.g., "Pirate,2")</p>
            <textarea id="rolesInput" placeholder="Pirate,2\nLead Singer,1" oninput="validateAndSave('roles')"></textarea>
            <div id="rolesError" class="error"></div>
            <button onclick="exportCSV('roles')">Export Roles to CSV</button>
            <input type="file" id="rolesFile" accept=".csv" onchange="importCSV('roles')">
        </div>

        <!-- Competencies Tab -->
        <div id="competencies" class="tab">
            <h2>Competencies</h2>
            <p>Set standard and competency roles for each artist.</p>
            <table id="competenciesTable">
                <thead>
                    <tr>
                        <th>Artist</th>
                        <th>Standard Roles</th>
                        <th>Additional Competency Roles</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            <button onclick="exportCompetencies()">Export Competencies to CSV</button>
            <input type="file" id="competenciesFile" accept=".csv" onchange="importCompetencies()">
        </div>

        <!-- Conflicts Tab -->
        <div id="conflicts" class="tab">
            <h2>Conflicts</h2>
            <p>Set conflicting roles for each role.</p>
            <table id="conflictsTable">
                <thead>
                    <tr>
                        <th>Role</th>
                        <th>Conflicting Roles</th>
                        <th>Selected Conflicts</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            <button onclick="exportConflicts()">Export Conflicts to CSV</button>
            <input type="file" id="conflictsFile" accept=".csv" onchange="importConflicts()">
        </div>

        <!-- Absences Tab -->
        <div id="absences" class="tab">
            <h2>Absences & Overrides</h2>
            <div id="errorMessages" class="error"></div>
            <p>Show Date and Time:</p>
            <input type="date" id="showDate" onchange="updateAbsences()">
            <input type="time" id="showTime" onchange="updateAbsences()">
            <p>Comments:</p>
            <textarea id="showComments" placeholder="Additional notes..." onchange="updateAbsences()"></textarea>
            <p>Select absent artists:</p>
            <div id="absentArtistsContainer"></div>
            <p>Overrides (replace an artist's role with another artist):</p>
            <div id="overridesList"></div>
            <button onclick="addOverride()" title="Select a new artist to take over a role from another artist">Add Override</button>
            <button onclick="resetAbsences()">Reset Absences</button>
        </div>

        <!-- Line-Up Tab -->
        <div id="lineup" class="tab">
            <h2>Generated Line-Up</h2>
            <div id="lineUpErrors" class="error"></div>
            <p id="lineUpDateTime"></p>
            <p id="lineUpComments"></p>
            <label><input type="checkbox" id="hideStandard" onchange="filterLineUp()"> Hide Standard Assignments</label>
            <table id="lineUpTable">
                <thead>
                    <tr>
                        <th onclick="sortLineUp(0)">Role</th>
                        <th onclick="sortLineUp(1)">Artist</th>
                        <th onclick="sortLineUp(2)">Status</th>
                    </tr>
                </thead>
                <tbody id="lineUpBody"></tbody>
            </table>
            <button onclick="exportToPNG()">Export to PNG</button>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard" class="tab">
            <h2>Dashboard</h2>
            <canvas id="rolesChart"></canvas>
            <canvas id="loadChart"></canvas>
            <table id="dashboardTable">
                <thead>
                    <tr>
                        <th>Statistic</th>
                        <th>Value</th>
                    </tr>
                </thead>
                <tbody id="dashboardBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        let rolesChart, loadChart;

        // Tab handling
        function openTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            document.querySelector(`button[onclick="openTab('${tabName}')"]`).classList.add('active');
            if (['competencies', 'conflicts', 'absences'].includes(tabName)) loadDropdowns();
            if (tabName === 'lineup') generateLineUp();
            if (tabName === 'dashboard') generateDashboard();
        }

        // Load saved data on page load
        window.onload = function() {
            loadData('artists', 'artistsInput');
            loadData('roles', 'rolesInput');
            loadDropdowns();
            const darkMode = localStorage.getItem('darkMode') || 'light';
            document.getElementById('darkModeToggle').value = darkMode;
            if (darkMode === 'dark') document.body.classList.add('dark-mode');
        };

        // Save data to localStorage
        function saveData(key) {
            const input = document.getElementById(`${key}Input`);
            localStorage.setItem(key, input.value);
            loadDropdowns();
        }

        // Validate and save data
        function validateAndSave(key) {
            const input = document.getElementById(`${key}Input`);
            const errorDiv = document.getElementById(`${key}Error`);
            errorDiv.innerHTML = '';
            const tabBtn = document.getElementById(`${key}Tab`);
            const lines = parseInput(input.value);
            const names = lines.map(line => line[0]);
            const duplicates = names.filter((name, index) => names.indexOf(name) !== index);
            if (duplicates.length > 0) {
                errorDiv.innerHTML = `Duplicate ${key}: ${duplicates.join(', ')}`;
                tabBtn.classList.add('error');
                return;
            }
            if (key === 'roles' && lines.some(line => line.length !== 2 || isNaN(parseInt(line[1])))) {
                errorDiv.innerHTML = 'Invalid format: Use "Name,Count" (e.g., "Pirate,2")';
                tabBtn.classList.add('error');
                return;
            }
            tabBtn.classList.remove('error');
            saveData(key);
        }

        // Load data from localStorage
        function loadData(key, inputId) {
            const data = localStorage.getItem(key);
            if (data) document.getElementById(inputId).value = data;
        }

        // Parse input text
        function parseInput(text) {
            return text.trim().split('\n').map(line => line.split(','));
        }

        // Import CSV
        function importCSV(key) {
            const fileInput = document.getElementById(`${key}File`);
            const file = fileInput.files[0];
            if (file) {
                Papa.parse(file, {
                    complete: function(results) {
                        const data = results.data.map(row => row.join(',')).join('\n');
                        document.getElementById(`${key}Input`).value = data;
                        validateAndSave(key);
                    },
                    error: function() {
                        alert(`Failed to import ${key} CSV`);
                    }
                });
            }
        }

        // Export CSV
        function exportCSV(key) {
            const data = localStorage.getItem(key);
            const link = document.createElement('a');
            link.href = 'data:text/csv;charset=utf-8,' + encodeURI(data);
            link.download = `${key}.csv`;
            link.click();
        }

        // Export competencies to CSV
        function exportCompetencies() {
            const competencies = JSON.parse(localStorage.getItem('competencies') || '{}');
            const csv = Object.entries(competencies).map(([artist, { standardRoles, competencyRoles }]) => 
                `${artist},${standardRoles.join(';')},${competencyRoles.join(';')}`
            ).join('\n');
            const link = document.createElement('a');
            link.href = 'data:text/csv;charset=utf-8,' + encodeURI('Artist,StandardRoles,CompetencyRoles\n' + csv);
            link.download = 'competencies.csv';
            link.click();
        }

        // Import competencies from CSV
        function importCompetencies() {
            const fileInput = document.getElementById('competenciesFile');
            const file = fileInput.files[0];
            if (file) {
                Papa.parse(file, {
                    complete: function(results) {
                        const allCompetencies = {};
                        results.data.slice(1).forEach(row => {
                            if (row.length >= 3) {
                                const [artist, standardRoles, competencyRoles] = [row[0], row[1].split(';'), row[2].split(';')];
                                allCompetencies[artist] = { standardRoles, competencyRoles };
                            }
                        });
                        localStorage.setItem('competencies', JSON.stringify(allCompetencies));
                        loadCompetencies();
                    },
                    error: function() {
                        alert('Failed to import competencies CSV');
                    }
                });
            }
        }

        // Export conflicts to CSV
        function exportConflicts() {
            const conflicts = JSON.parse(localStorage.getItem('conflicts') || '{}');
            const csv = Object.entries(conflicts).map(([role, conf]) => `${role},${conf.join(';')}`).join('\n');
            const link = document.createElement('a');
            link.href = 'data:text/csv;charset=utf-8,' + encodeURI(csv);
            link.download = 'conflicts.csv';
            link.click();
        }

        // Import conflicts from CSV
        function importConflicts() {
            const fileInput = document.getElementById('conflictsFile');
            const file = fileInput.files[0];
            if (file) {
                Papa.parse(file, {
                    complete: function(results) {
                        const allConflicts = {};
                        results.data.forEach(row => {
                            if (row.length >= 2) {
                                const [role, conflicts] = [row[0], row[1].split(';')];
                                allConflicts[role] = conflicts;
                            }
                        });
                        localStorage.setItem('conflicts', JSON.stringify(allConflicts));
                        loadConflicts();
                    },
                    error: function() {
                        alert('Failed to import conflicts CSV');
                    }
                });
            }
        }

        // Load dropdowns and tables
        function loadDropdowns() {
            const artists = parseInput(localStorage.getItem('artists') || '');
            const roles = parseInput(localStorage.getItem('roles') || '');

            // Competencies table
            const compTableBody = document.querySelector('#competenciesTable tbody');
            compTableBody.innerHTML = '';
            artists.forEach(([name]) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${name}</td>
                    <td class="roles-container">${roles.map(([r]) => `
                        <div class="checkbox-container">
                            <input type="checkbox" class="standardRoles" data-artist="${name}" value="${r}" onchange="saveCompetencies()">
                            <label>${r}</label>
                        </div>
                    `).join('')}</td>
                    <td class="roles-container">${roles.map(([r]) => `
                        <div class="checkbox-container">
                            <input type="checkbox" class="competencyRoles" data-artist="${name}" value="${r}" onchange="saveCompetencies()">
                            <label>${r}</label>
                        </div>
                    `).join('')}</td>
                `;
                compTableBody.appendChild(row);
            });
            loadCompetencies();

            // Conflicts table
            const conflictsTableBody = document.querySelector('#conflictsTable tbody');
            conflictsTableBody.innerHTML = '';
            roles.forEach(([name]) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${name}</td>
                    <td class="roles-container">${roles.map(([r]) => `
                        <div class="checkbox-container">
                            <input type="checkbox" class="conflictRoles" data-role="${name}" value="${r}" onchange="saveConflicts()">
                            <label>${r}</label>
                        </div>
                    `).join('')}</td>
                    <td class="selectedConflicts" data-role="${name}"></td>
                `;
                conflictsTableBody.appendChild(row);
            });
            loadConflicts();

            // Absences
            const absentContainer = document.getElementById('absentArtistsContainer');
            absentContainer.innerHTML = artists.map(([name]) => `
                <div class="checkbox-container">
                    <input type="checkbox" class="absentArtist" value="${name}" onchange="updateAbsences()">
                    <label>${name}</label>
                </div>
            `).join('');
            const showDate = document.getElementById('showDate');
            const showTime = document.getElementById('showTime');
            const showComments = document.getElementById('showComments');
            showDate.value = localStorage.getItem('showDate') || new Date().toISOString().split('T')[0];
            showTime.value = localStorage.getItem('showTime') || '19:00';
            showComments.value = localStorage.getItem('showComments') || '';
            loadAbsences();
        }

        // Save and load competencies
        function saveCompetencies() {
            const allCompetencies = {};
            document.querySelectorAll('#competenciesTable tbody tr').forEach(row => {
                const artist = row.querySelector('.standardRoles').dataset.artist;
                const standardRoles = Array.from(row.querySelectorAll('.standardRoles:checked')).map(cb => cb.value);
                const allCompetencyRoles = Array.from(row.querySelectorAll('.competencyRoles:checked')).map(cb => cb.value);
                const competencyRoles = allCompetencyRoles.filter(role => !standardRoles.includes(role));
                allCompetencies[artist] = { standardRoles, competencyRoles };
            });
            localStorage.setItem('competencies', JSON.stringify(allCompetencies));
        }

        function loadCompetencies() {
            const allCompetencies = JSON.parse(localStorage.getItem('competencies') || '{}');
            document.querySelectorAll('#competenciesTable tbody tr').forEach(row => {
                const artist = row.querySelector('.standardRoles').dataset.artist;
                const comp = allCompetencies[artist] || { standardRoles: [], competencyRoles: [] };
                row.querySelectorAll('.standardRoles').forEach(cb => cb.checked = comp.standardRoles.includes(cb.value));
                row.querySelectorAll('.competencyRoles').forEach(cb => cb.checked = comp.standardRoles.includes(cb.value) || comp.competencyRoles.includes(cb.value));
            });
        }

        // Save and load conflicts
        function saveConflicts() {
            const allConflicts = {};
            document.querySelectorAll('#conflictsTable tbody tr').forEach(row => {
                const role = row.querySelector('.conflictRoles').dataset.role;
                const conflicts = Array.from(row.querySelectorAll('.conflictRoles:checked')).map(cb => cb.value);
                allConflicts[role] = conflicts.includes(role) ? conflicts : [...conflicts, role];
            });
            // Ensure symmetry
            Object.keys(allConflicts).forEach(role => {
                allConflicts[role].forEach(conflict => {
                    if (!allConflicts[conflict]) allConflicts[conflict] = [];
                    if (!allConflicts[conflict].includes(role)) allConflicts[conflict].push(role);
                });
            });
            localStorage.setItem('conflicts', JSON.stringify(allConflicts));
            loadConflicts();
        }

        function loadConflicts() {
            const allConflicts = JSON.parse(localStorage.getItem('conflicts') || '{}');
            document.querySelectorAll('#conflictsTable tbody tr').forEach(row => {
                const role = row.querySelector('.conflictRoles').dataset.role;
                const conflicts = allConflicts[role] || [role];
                row.querySelectorAll('.conflictRoles').forEach(cb => cb.checked = conflicts.includes(cb.value));
                row.querySelector('.selectedConflicts').textContent = conflicts.join(', ');
            });
        }

        // Add override
        function addOverride() {
            const artists = parseInput(localStorage.getItem('artists') || '');
            const roles = parseInput(localStorage.getItem('roles') || '');
            const div = document.createElement('div');
            div.className = 'dynamic-entry';
            div.innerHTML = `
                <label>New Artist:</label><select class="overrideArtist" onchange="updateAbsences()">${artists.map(([name]) => `<option value="${name}">${name}</option>`).join('')}</select>
                <label>Role:</label><select class="overrideRole" onchange="updateAbsences()">${roles.map(([name]) => `<option value="${name}">${name}</option>`).join('')}</select>
                <label>From Artist:</label><select class="overrideSource" onchange="updateAbsences()">${artists.map(([name]) => `<option value="${name}">${name}</option>`).join('')}</select>
                <button class="remove-btn" onclick="this.parentElement.remove(); updateAbsences()">Remove</button>
            `;
            document.getElementById('overridesList').appendChild(div);
        }

        // Save and load absences
        function updateAbsences() {
            const absent = Array.from(document.querySelectorAll('.absentArtist:checked')).map(cb => cb.value);
            const overrides = Array.from(document.querySelectorAll('#overridesList .dynamic-entry')).map(entry => ({
                artist: entry.querySelector('.overrideArtist').value,
                role: entry.querySelector('.overrideRole').value,
                source: entry.querySelector('.overrideSource').value
            }));
            const showDate = document.getElementById('showDate').value;
            const showTime = document.getElementById('showTime').value;
            const showComments = document.getElementById('showComments').value;
            localStorage.setItem('absences', JSON.stringify({ absent, overrides }));
            localStorage.setItem('showDate', showDate);
            localStorage.setItem('showTime', showTime);
            localStorage.setItem('showComments', showComments);
            generateLineUp();
        }

        function loadAbsences() {
            const data = JSON.parse(localStorage.getItem('absences') || '{}');
            document.querySelectorAll('.absentArtist').forEach(cb => cb.checked = (data.absent || []).includes(cb.value));
            document.getElementById('overridesList').innerHTML = '';
            (data.overrides || []).forEach(({ artist, role, source }) => {
                addOverride();
                const last = document.querySelector('#overridesList .dynamic-entry:last-child');
                last.querySelector('.overrideArtist').value = artist;
                last.querySelector('.overrideRole').value = role;
                last.querySelector('.overrideSource').value = source;
            });
        }

        function resetAbsences() {
            document.querySelectorAll('.absentArtist').forEach(cb => cb.checked = false);
            document.getElementById('overridesList').innerHTML = '';
            document.getElementById('showDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('showTime').value = '19:00';
            document.getElementById('showComments').value = '';
            updateAbsences();
        }

        // Generate line-up
        function generateLineUp() {
            const artists = parseInput(localStorage.getItem('artists') || '');
            const roles = parseInput(localStorage.getItem('roles') || '');
            const competencies = JSON.parse(localStorage.getItem('competencies') || '{}');
            const conflicts = JSON.parse(localStorage.getItem('conflicts') || '{}');
            const absences = JSON.parse(localStorage.getItem('absences') || '{}');

            // Initialize data structures
            artistDict = {};
            artists.forEach(([name]) => {
                artistDict[name] = {
                    absent: absences.absent?.includes(name) || false,
                    standardRoles: competencies[name]?.standardRoles || [],
                    competencyRoles: competencies[name]?.competencyRoles || [],
                    assignedRoles: []
                };
            });

            const roleDict = {};
            roles.forEach(([name, qty]) => {
                roleDict[name] = { qty: parseInt(qty), conflicts: conflicts[name] || [name], assignments: [] };
            });

            const lineUpBody = document.getElementById('lineUpBody');
            const errorMessages = document.getElementById('errorMessages');
            const lineUpErrors = document.getElementById('lineUpErrors');
            const absencesTab = document.getElementById('absencesTab');
            const lineupTab = document.getElementById('lineupTab');
            lineUpBody.innerHTML = '';
            errorMessages.innerHTML = '';
            lineUpErrors.innerHTML = '';

            // Apply overrides first
            absences.overrides?.forEach(({ artist, role, source }) => {
                if (roleDict[role] && !artistDict[artist].absent && !artistDict[artist].assignedRoles.includes(role)) {
                    const canAssign = !roleDict[role].conflicts.some(conflict => artistDict[artist].assignedRoles.includes(conflict));
                    if (canAssign && roleDict[role].assignments.length < roleDict[role].qty) {
                        roleDict[role].assignments.push({ artist, status: `Override from ${source}` });
                        artistDict[artist].assignedRoles.push(role);
                        if (source !== artist && artistDict[source].standardRoles.includes(role)) {
                            artistDict[source].standardRoles = artistDict[source].standardRoles.filter(r => r !== role);
                        }
                    } else {
                        const msg = `<p>Override conflict: ${artist} cannot take ${role} due to conflicts or full allocation.</p>`;
                        errorMessages.innerHTML += msg;
                        lineUpErrors.innerHTML += msg;
                    }
                }
            });

            // Assign standard roles for present artists
            Object.keys(artistDict).forEach(artist => {
                if (!artistDict[artist].absent) {
                    artistDict[artist].standardRoles.forEach(role => {
                        if (roleDict[role] && roleDict[role].assignments.length < roleDict[role].qty && !artistDict[artist].assignedRoles.includes(role)) {
                            const canAssign = !roleDict[role].conflicts.some(conflict => artistDict[artist].assignedRoles.includes(conflict));
                            if (canAssign) {
                                roleDict[role].assignments.push({ artist, status: 'Standard' });
                                artistDict[artist].assignedRoles.push(role);
                            }
                        }
                    });
                }
            });

            // Handle absent artists with basic assignment
            absences.absent?.forEach(absentArtist => {
                artistDict[absentArtist].standardRoles.forEach(role => {
                    if (roleDict[role] && !roleDict[role].assignments.some(a => a.artist === absentArtist)) {
                        const candidates = Object.keys(artistDict).filter(a =>
                            !artistDict[a].absent &&
                            artistDict[a].competencyRoles.includes(role) &&
                            !artistDict[a].assignedRoles.includes(role) &&
                            !roleDict[role].conflicts.some(conflict => artistDict[a].assignedRoles.includes(conflict))
                        );
                        const replacement = candidates.find(c => roleDict[role].assignments.length < roleDict[role].qty);
                        if (replacement) {
                            roleDict[role].assignments.push({ artist: replacement, status: `Replacement for ${absentArtist}` });
                            artistDict[replacement].assignedRoles.push(role);
                        } else {
                            const msg = `<p>No replacement found for ${role} of ${absentArtist}.</p>`;
                            errorMessages.innerHTML += msg;
                            lineUpErrors.innerHTML += msg;
                        }
                    }
                });
            });

            // Fill remaining roles
            Object.keys(roleDict).forEach(role => {
                while (roleDict[role].assignments.length < roleDict[role].qty) {
                    const candidates = Object.keys(artistDict).filter(a =>
                        !artistDict[a].absent &&
                        artistDict[a].competencyRoles.includes(role) &&
                        !artistDict[a].assignedRoles.includes(role) &&
                        !roleDict[role].conflicts.some(conflict => artistDict[a].assignedRoles.includes(conflict))
                    );
                    const artist = candidates[0];
                    if (artist) {
                        roleDict[role].assignments.push({ artist, status: 'Assigned' });
                        artistDict[artist].assignedRoles.push(role);
                    } else {
                        const msg = `<p>Insufficient artists for ${role}: ${roleDict[role].assignments.length}/${roleDict[role].qty} assigned.</p>`;
                        errorMessages.innerHTML += msg;
                        lineUpErrors.innerHTML += msg;
                        break;
                    }
                }
                if (roleDict[role].assignments.length > roleDict[role].qty) {
                    const msg = `<p>Too many assignments for ${role}: ${roleDict[role].assignments.length}/${roleDict[role].qty} required.</p>`;
                    errorMessages.innerHTML += msg;
                    lineUpErrors.innerHTML += msg;
                }
            });

            // Display line-up
            const showDate = document.getElementById('showDate').value;
            const showTime = document.getElementById('showTime').value;
            const showComments = document.getElementById('showComments').value;
            document.getElementById('lineUpDateTime').textContent = `Show Date: ${showDate} ${showTime}`;
            document.getElementById('lineUpComments').textContent = `Comments: ${showComments}`;
            Object.keys(roleDict).forEach(role => {
                roleDict[role].assignments.forEach(({ artist, status }) => {
                    const row = document.createElement('tr');
                    row.dataset.status = status;
                    row.innerHTML = `<td>${role}</td><td>${artist}</td><td>${status}</td>`;
                    lineUpBody.appendChild(row);
                });
            });
            filterLineUp();

            // Update tab indicators
            absencesTab.classList.toggle('error', errorMessages.innerHTML !== '');
            lineupTab.classList.toggle('error', lineUpErrors.innerHTML !== '');
        }

        // Filter line-up
        function filterLineUp() {
            const hideStandard = document.getElementById('hideStandard').checked;
            document.querySelectorAll('#lineUpBody tr').forEach(row => {
                row.style.display = hideStandard && row.dataset.status === 'Standard' ? 'none' : '';
            });
        }

        // Sort line-up
        function sortLineUp(column) {
            const tbody = document.getElementById('lineUpBody');
            const rows = Array.from(tbody.rows);
            rows.sort((a, b) => a.cells[column].textContent.localeCompare(b.cells[column].textContent));
            rows.forEach(row => tbody.appendChild(row));
            filterLineUp();
        }

        // Export to PNG
        function exportToPNG() {
            html2canvas(document.getElementById('lineup'), { backgroundColor: document.body.classList.contains('dark-mode') ? '#444' : '#fff' }).then(canvas => {
                const link = document.createElement('a');
                link.download = 'show_lineup.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        }

        // Generate dashboard
        function generateDashboard() {
            const artists = parseInput(localStorage.getItem('artists') || '');
            const roles = parseInput(localStorage.getItem('roles') || '');
            const competencies = JSON.parse(localStorage.getItem('competencies') || '{}');
            const conflicts = JSON.parse(localStorage.getItem('conflicts') || '{}');
            const absences = JSON.parse(localStorage.getItem('absences') || '{}');

            const dashboardBody = document.getElementById('dashboardBody');
            dashboardBody.innerHTML = '';

            dashboardBody.innerHTML += `<tr><td>Total Artists</td><td>${artists.length}</td></tr>`;

            let filledRoles = 0;
            generateLineUp();
            document.querySelectorAll('#lineUpBody tr').forEach(() => filledRoles++);
            const totalRoles = roles.reduce((sum, [, qty]) => sum + parseInt(qty), 0);
            dashboardBody.innerHTML += `<tr><td>Total Roles Filled</td><td>${filledRoles}</td></tr>`;

            const conflictCount = Object.values(conflicts).reduce((acc, conf) => acc + conf.length, 0);
            dashboardBody.innerHTML += `<tr><td>Total Conflicts Defined</td><td>${conflictCount}</td></tr>`;

            if (rolesChart) rolesChart.destroy();
            if (loadChart) loadChart.destroy();

            rolesChart = new Chart(document.getElementById('rolesChart'), {
                type: 'pie',
                data: {
                    labels: ['Filled', 'Remaining'],
                    datasets: [{ data: [filledRoles, totalRoles - filledRoles], backgroundColor: ['#36A2EB', '#FF6384'] }]
                },
                options: { title: { display: true, text: 'Role Allocation' } }
            });

            const loadOverview = {};
            Object.keys(artistDict).forEach(artist => {
                loadOverview[artist] = artistDict[artist].assignedRoles.length;
            });
            loadChart = new Chart(document.getElementById('loadChart'), {
                type: 'bar',
                data: {
                    labels: Object.keys(loadOverview),
                    datasets: [{ label: 'Roles Assigned', data: Object.values(loadOverview), backgroundColor: '#4BC0C0' }]
                },
                options: { scales: { y: { beginAtZero: true } }, title: { display: true, text: 'Load Overview' } }
            });
        }

        // Toggle dark mode
        function toggleDarkMode() {
            const mode = document.getElementById('darkModeToggle').value;
            document.body.classList.toggle('dark-mode', mode === 'dark');
            localStorage.setItem('darkMode', mode);
        }

        // Global artistDict for dashboard access
        let artistDict = {};
    </script>
</body>
</html>
