<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Show Line-Up Scheduler</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
            color: #333;
            transition: all 0.3s;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s;
        }
        .tab {
            display: none;
        }
        .tab.active {
            display: block;
        }
        .tab-buttons {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .tab-btn {
            padding: 12px 24px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            flex: 1;
            min-width: 100px;
        }
        .tab-btn.active {
            background-color: #2980b9;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px;
            border: 1px solid #ddd;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        textarea, select, input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 16px;
        }
        textarea {
            min-height: 150px;
        }
        input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }
        button {
            padding: 12px 24px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
            width: 100%;
            font-size: 16px;
        }
        button:hover {
            background-color: #27ae60;
        }
        .dynamic-entry {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            align-items: center;
        }
        .remove-btn {
            background-color: #e74c3c;
            padding: 5px 10px;
            width: auto;
        }
        .remove-btn:hover {
            background-color: #c0392b;
        }
        .error {
            color: red;
            margin: 10px 0;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }
        .roles-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        @media (max-width: 600px) {
            .container { padding: 10px; }
            .tab-btn { padding: 10px; font-size: 14px; }
            th, td { padding: 8px; font-size: 14px; }
            textarea, select, input { font-size: 14px; }
            button { padding: 10px; font-size: 14px; }
            .dynamic-entry { flex-direction: column; }
        }
        .dark-mode {
            background-color: #333;
            color: #fff;
        }
        .dark-mode .container {
            background-color: #444;
            box-shadow: 0 4px 8px rgba(255, 255, 255, 0.1);
        }
        .dark-mode th {
            background-color: #2980b9;
        }
        .dark-mode tr:nth-child(even) {
            background-color: #555;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Show Line-Up Scheduler</h1>
        <select id="darkModeToggle" onchange="toggleDarkMode()">
            <option value="light">Light Mode</option>
            <option value="dark">Dark Mode</option>
        </select>

        <!-- Tab Buttons -->
        <div class="tab-buttons">
            <button class="tab-btn active" onclick="openTab('artists')">Artists</button>
            <button class="tab-btn" onclick="openTab('roles')">Roles</button>
            <button class="tab-btn" onclick="openTab('competencies')">Competencies</button>
            <button class="tab-btn" onclick="openTab('conflicts')">Conflicts</button>
            <button class="tab-btn" onclick="openTab('absences')">Absences</button>
            <button class="tab-btn" onclick="openTab('lineup')">Line-Up</button>
            <button class="tab-btn" onclick="openTab('dashboard')">Dashboard</button>
        </div>

        <!-- Artists Tab -->
        <div id="artists" class="tab active">
            <h2>Artists</h2>
            <p>Add one artist per line: "Name" (e.g., "John")</p>
            <textarea id="artistsInput" placeholder="John\nEmma\nAlex" onchange="saveData('artists')"></textarea>
            <input type="file" id="artistsFile" accept=".csv" onchange="importCSV('artists')">
        </div>

        <!-- Roles Tab -->
        <div id="roles" class="tab">
            <h2>Roles</h2>
            <p>Add one role per line: "Name,Count" (e.g., "Pirate,2")</p>
            <textarea id="rolesInput" placeholder="Pirate,2\nLead Singer,1" onchange="saveData('roles')"></textarea>
            <input type="file" id="rolesFile" accept=".csv" onchange="importCSV('roles')">
        </div>

        <!-- Competencies Tab -->
        <div id="competencies" class="tab">
            <h2>Competencies</h2>
            <p>Set standard and competency roles for each artist.</p>
            <table id="competenciesTable">
                <thead>
                    <tr>
                        <th>Artist</th>
                        <th>Standard Roles</th>
                        <th>Competency Roles</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <!-- Conflicts Tab -->
        <div id="conflicts" class="tab">
            <h2>Conflicts</h2>
            <p>Set conflicting roles for each role.</p>
            <table id="conflictsTable">
                <thead>
                    <tr>
                        <th>Role</th>
                        <th>Conflicting Roles</th>
                        <th>Selected Conflicts</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <!-- Absences Tab -->
        <div id="absences" class="tab">
            <h2>Absences & Overrides</h2>
            <div id="errorMessages" class="error"></div>
            <p>Date of Show:</p>
            <input type="date" id="showDate" onchange="updateAbsences()">
            <p>Select absent artists:</p>
            <div id="absentArtistsContainer"></div>
            <p>Overrides (artist takes over a specific role from another artist):</p>
            <div id="overridesList"></div>
            <button onclick="addOverride()">Add Override</button>
            <button onclick="resetAbsences()">Reset Absences</button>
        </div>

        <!-- Line-Up Tab -->
        <div id="lineup" class="tab">
            <h2>Generated Line-Up</h2>
            <p id="lineUpDate"></p>
            <table id="lineUpTable">
                <thead>
                    <tr>
                        <th>Role</th>
                        <th>Artist</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="lineUpBody"></tbody>
            </table>
            <button onclick="exportToPNG()">Export to PNG</button>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard" class="tab">
            <h2>Dashboard</h2>
            <table id="dashboardTable">
                <thead>
                    <tr>
                        <th>Statistic</th>
                        <th>Value</th>
                    </tr>
                </thead>
                <tbody id="dashboardBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        // Tab handling
        function openTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            document.querySelector(`button[onclick="openTab('${tabName}')"]`).classList.add('active');
            if (['competencies', 'conflicts', 'absences'].includes(tabName)) loadDropdowns();
            if (tabName === 'lineup') generateLineUp();
            if (tabName === 'dashboard') generateDashboard();
        }

        // Load saved data on page load
        window.onload = function() {
            loadData('artists', 'artistsInput');
            loadData('roles', 'rolesInput');
            loadDropdowns();
            const darkMode = localStorage.getItem('darkMode') || 'light';
            document.getElementById('darkModeToggle').value = darkMode;
            if (darkMode === 'dark') document.body.classList.add('dark-mode');
        };

        // Save data to localStorage
        function saveData(key) {
            const input = document.getElementById(`${key}Input`);
            localStorage.setItem(key, input.value);
            loadDropdowns();
        }

        // Load data from localStorage
        function loadData(key, inputId) {
            const data = localStorage.getItem(key);
            if (data) document.getElementById(inputId).value = data;
        }

        // Parse input text
        function parseInput(text) {
            return text.trim().split('\n').map(line => line.split(','));
        }

        // Import CSV
        function importCSV(key) {
            const fileInput = document.getElementById(`${key}File`);
            const file = fileInput.files[0];
            if (file) {
                Papa.parse(file, {
                    complete: function(results) {
                        const data = results.data.map(row => row.join(',')).join('\n');
                        document.getElementById(`${key}Input`).value = data;
                        saveData(key);
                    },
                    error: function() {
                        alert(`Failed to import ${key} CSV`);
                    }
                });
            }
        }

        // Load dropdowns and tables
        function loadDropdowns() {
            const artists = parseInput(localStorage.getItem('artists') || '');
            const roles = parseInput(localStorage.getItem('roles') || '');

            // Competencies table
            const compTableBody = document.querySelector('#competenciesTable tbody');
            compTableBody.innerHTML = '';
            artists.forEach(([name]) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${name}</td>
                    <td class="roles-container">${roles.map(([r]) => `
                        <div class="checkbox-container">
                            <input type="checkbox" class="standardRoles" data-artist="${name}" value="${r}" onchange="saveCompetencies()">
                            <label>${r}</label>
                        </div>
                    `).join('')}</td>
                    <td class="roles-container">${roles.map(([r]) => `
                        <div class="checkbox-container">
                            <input type="checkbox" class="competencyRoles" data-artist="${name}" value="${r}" onchange="saveCompetencies()">
                            <label>${r}</label>
                        </div>
                    `).join('')}</td>
                `;
                compTableBody.appendChild(row);
            });
            loadCompetencies();

            // Conflicts table
            const conflictsTableBody = document.querySelector('#conflictsTable tbody');
            conflictsTableBody.innerHTML = '';
            roles.forEach(([name]) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${name}</td>
                    <td class="roles-container">${roles.map(([r]) => `
                        <div class="checkbox-container">
                            <input type="checkbox" class="conflictRoles" data-role="${name}" value="${r}" onchange="saveConflicts()">
                            <label>${r}</label>
                        </div>
                    `).join('')}</td>
                    <td class="selectedConflicts" data-role="${name}"></td>
                `;
                conflictsTableBody.appendChild(row);
            });
            loadConflicts();

            // Absences
            const absentContainer = document.getElementById('absentArtistsContainer');
            absentContainer.innerHTML = artists.map(([name]) => `
                <div class="checkbox-container">
                    <input type="checkbox" class="absentArtist" value="${name}" onchange="updateAbsences()">
                    <label>${name}</label>
                </div>
            `).join('');
            const showDate = document.getElementById('showDate');
            showDate.value = localStorage.getItem('showDate') || new Date().toISOString().split('T')[0];
            loadAbsences();
        }

        // Save and load competencies
        function saveCompetencies() {
            const allCompetencies = {};
            document.querySelectorAll('#competenciesTable tbody tr').forEach(row => {
                const artist = row.querySelector('.standardRoles').dataset.artist;
                const standardRoles = Array.from(row.querySelectorAll('.standardRoles:checked')).map(cb => cb.value);
                const competencyRoles = Array.from(row.querySelectorAll('.competencyRoles:checked')).map(cb => cb.value);
                allCompetencies[artist] = { standardRoles, competencyRoles };
            });
            localStorage.setItem('competencies', JSON.stringify(allCompetencies));
        }

        function loadCompetencies() {
            const allCompetencies = JSON.parse(localStorage.getItem('competencies') || '{}');
            document.querySelectorAll('#competenciesTable tbody tr').forEach(row => {
                const artist = row.querySelector('.standardRoles').dataset.artist;
                const comp = allCompetencies[artist] || { standardRoles: [], competencyRoles: [] };
                row.querySelectorAll('.standardRoles').forEach(cb => cb.checked = comp.standardRoles.includes(cb.value));
                row.querySelectorAll('.competencyRoles').forEach(cb => cb.checked = comp.competencyRoles.includes(cb.value));
            });
        }

        // Save and load conflicts
        function saveConflicts() {
            const allConflicts = {};
            document.querySelectorAll('#conflictsTable tbody tr').forEach(row => {
                const role = row.querySelector('.conflictRoles').dataset.role;
                const conflicts = Array.from(row.querySelectorAll('.conflictRoles:checked')).map(cb => cb.value);
                allConflicts[role] = conflicts.includes(role) ? conflicts : [...conflicts, role]; // Self-conflict
                row.querySelector('.selectedConflicts').textContent = allConflicts[role].join(', ');
            });
            localStorage.setItem('conflicts', JSON.stringify(allConflicts));
        }

        function loadConflicts() {
            const allConflicts = JSON.parse(localStorage.getItem('conflicts') || '{}');
            document.querySelectorAll('#conflictsTable tbody tr').forEach(row => {
                const role = row.querySelector('.conflictRoles').dataset.role;
                const conflicts = allConflicts[role] || [role];
                row.querySelectorAll('.conflictRoles').forEach(cb => cb.checked = conflicts.includes(cb.value));
                row.querySelector('.selectedConflicts').textContent = conflicts.join(', ');
            });
        }

        // Add override
        function addOverride() {
            const artists = parseInput(localStorage.getItem('artists') || '');
            const roles = parseInput(localStorage.getItem('roles') || '');
            const div = document.createElement('div');
            div.className = 'dynamic-entry';
            div.innerHTML = `
                <select class="overrideArtist" onchange="updateAbsences()">${artists.map(([name]) => `<option value="${name}">${name}</option>`).join('')}</select>
                <select class="overrideRole" onchange="updateAbsences()">${roles.map(([name]) => `<option value="${name}">${name}</option>`).join('')}</select>
                <select class="overrideSource" onchange="updateAbsences()">${artists.map(([name]) => `<option value="${name}">${name}</option>`).join('')}</select>
                <button class="remove-btn" onclick="this.parentElement.remove(); updateAbsences()">Remove</button>
            `;
            document.getElementById('overridesList').appendChild(div);
        }

        // Save and load absences
        function updateAbsences() {
            const absent = Array.from(document.querySelectorAll('.absentArtist:checked')).map(cb => cb.value);
            const overrides = Array.from(document.querySelectorAll('#overridesList .dynamic-entry')).map(entry => ({
                artist: entry.querySelector('.overrideArtist').value,
                role: entry.querySelector('.overrideRole').value,
                source: entry.querySelector('.overrideSource').value
            }));
            const showDate = document.getElementById('showDate').value;
            localStorage.setItem('absences', JSON.stringify({ absent, overrides }));
            localStorage.setItem('showDate', showDate);
            generateLineUp(); // Auto-generate after update
        }

        function loadAbsences() {
            const data = JSON.parse(localStorage.getItem('absences') || '{}');
            document.querySelectorAll('.absentArtist').forEach(cb => cb.checked = (data.absent || []).includes(cb.value));
            document.getElementById('overridesList').innerHTML = '';
            (data.overrides || []).forEach(({ artist, role, source }) => {
                addOverride();
                const last = document.querySelector('#overridesList .dynamic-entry:last-child');
                last.querySelector('.overrideArtist').value = artist;
                last.querySelector('.overrideRole').value = role;
                last.querySelector('.overrideSource').value = source;
            });
        }

        function resetAbsences() {
            document.querySelectorAll('.absentArtist').forEach(cb => cb.checked = false);
            document.getElementById('overridesList').innerHTML = '';
            document.getElementById('showDate').value = new Date().toISOString().split('T')[0];
            updateAbsences();
        }

        // Generate line-up
        function generateLineUp() {
            const artists = parseInput(localStorage.getItem('artists') || '');
            const roles = parseInput(localStorage.getItem('roles') || '');
            const competencies = JSON.parse(localStorage.getItem('competencies') || '{}');
            const conflicts = JSON.parse(localStorage.getItem('conflicts') || '{}');
            const absences = JSON.parse(localStorage.getItem('absences') || '{}');

            // Initialize data structures
            const artistDict = {};
            artists.forEach(([name]) => {
                artistDict[name] = {
                    absent: absences.absent?.includes(name) || false,
                    standardRoles: competencies[name]?.standardRoles || [],
                    competencyRoles: competencies[name]?.competencyRoles || [],
                    assignedRoles: []
                };
            });

            const roleDict = {};
            roles.forEach(([name, qty]) => {
                roleDict[name] = { qty: parseInt(qty), conflicts: conflicts[name] || [name], assignments: [] };
            });

            const lineUpBody = document.getElementById('lineUpBody');
            const errorMessages = document.getElementById('errorMessages');
            lineUpBody.innerHTML = '';
            errorMessages.innerHTML = '';

            // Apply overrides first
            absences.overrides?.forEach(({ artist, role, source }) => {
                if (!artistDict[artist].absent && roleDict[role] && !artistDict[artist].assignedRoles.includes(role)) {
                    const canAssign = !roleDict[role].conflicts.some(conflict => artistDict[artist].assignedRoles.includes(conflict));
                    if (canAssign && roleDict[role].assignments.length < roleDict[role].qty) {
                        roleDict[role].assignments.push({ artist, status: `Override from ${source}` });
                        artistDict[artist].assignedRoles.push(role);
                        if (source !== artist && artistDict[source].standardRoles.includes(role)) {
                            artistDict[source].standardRoles = artistDict[source].standardRoles.filter(r => r !== role);
                        }
                    } else {
                        errorMessages.innerHTML += `<p>Override conflict: ${artist} cannot take ${role} due to conflicts or full allocation.</p>`;
                    }
                }
            });

            // Assign standard roles for present artists
            Object.keys(artistDict).forEach(artist => {
                if (!artistDict[artist].absent) {
                    artistDict[artist].standardRoles.forEach(role => {
                        if (roleDict[role] && roleDict[role].assignments.length < roleDict[role].qty &&
                            !artistDict[artist].assignedRoles.includes(role)) {
                            const canAssign = !roleDict[role].conflicts.some(conflict => artistDict[artist].assignedRoles.includes(conflict));
                            if (canAssign) {
                                roleDict[role].assignments.push({ artist, status: 'Standard' });
                                artistDict[artist].assignedRoles.push(role);
                            }
                        }
                    });
                }
            });

            // Handle absent artists
            absences.absent?.forEach(absentArtist => {
                artistDict[absentArtist].standardRoles.forEach(role => {
                    if (!roleDict[role].assignments.some(a => a.artist === absentArtist)) {
                        const candidates = Object.keys(artistDict).filter(a =>
                            !artistDict[a].absent &&
                            artistDict[a].competencyRoles.includes(role) &&
                            !artistDict[a].assignedRoles.includes(role) &&
                            !roleDict[role].conflicts.some(conflict => artistDict[a].assignedRoles.includes(conflict))
                        );
                        const replacement = candidates.find(c => roleDict[role].assignments.length < roleDict[role].qty);
                        if (replacement) {
                            roleDict[role].assignments.push({ artist: replacement, status: `Replacement for ${absentArtist}` });
                            artistDict[replacement].assignedRoles.push(role);
                        } else {
                            errorMessages.innerHTML += `<p>No replacement found for ${role} of ${absentArtist}.</p>`;
                        }
                    }
                });
            });

            // Fill remaining roles
            Object.keys(roleDict).forEach(role => {
                while (roleDict[role].assignments.length < roleDict[role].qty) {
                    const candidates = Object.keys(artistDict).filter(a =>
                        !artistDict[a].absent &&
                        artistDict[a].competencyRoles.includes(role) &&
                        !artistDict[a].assignedRoles.includes(role) &&
                        !roleDict[role].conflicts.some(conflict => artistDict[a].assignedRoles.includes(conflict))
                    );
                    const artist = candidates[0];
                    if (artist) {
                        roleDict[role].assignments.push({ artist, status: 'Assigned' });
                        artistDict[artist].assignedRoles.push(role);
                    } else {
                        errorMessages.innerHTML += `<p>Insufficient artists for ${role}: ${roleDict[role].assignments.length}/${roleDict[role].qty} assigned.</p>`;
                        break;
                    }
                }
                if (roleDict[role].assignments.length > roleDict[role].qty) {
                    errorMessages.innerHTML += `<p>Too many assignments for ${role}: ${roleDict[role].assignments.length}/${roleDict[role].qty} required.</p>`;
                }
            });

            // Display line-up
            const showDate = document.getElementById('showDate').value;
            document.getElementById('lineUpDate').textContent = `Show Date: ${showDate}`;
            Object.keys(roleDict).forEach(role => {
                roleDict[role].assignments.forEach(({ artist, status }) => {
                    lineUpBody.innerHTML += `<tr><td>${role}</td><td>${artist}</td><td>${status}</td></tr>`;
                });
            });
        }

        // Export to PNG
        function exportToPNG() {
            html2canvas(document.getElementById('lineup')).then(canvas => {
                const link = document.createElement('a');
                link.download = 'show_lineup.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        }

        // Generate dashboard
        function generateDashboard() {
            const artists = parseInput(localStorage.getItem('artists') || '');
            const roles = parseInput(localStorage.getItem('roles') || '');
            const competencies = JSON.parse(localStorage.getItem('competencies') || '{}');
            const conflicts = JSON.parse(localStorage.getItem('conflicts') || '{}');
            const absences = JSON.parse(localStorage.getItem('absences') || '{}');

            const dashboardBody = document.getElementById('dashboardBody');
            dashboardBody.innerHTML = '';

            dashboardBody.innerHTML += `<tr><td>Total Artists</td><td>${artists.length}</td></tr>`;

            let filledRoles = 0;
            generateLineUp();
            document.querySelectorAll('#lineUpBody tr').forEach(() => filledRoles++);
            dashboardBody.innerHTML += `<tr><td>Total Roles Filled</td><td>${filledRoles}</td></tr>`;

            const conflictCount = Object.values(conflicts).reduce((acc, conf) => acc + conf.length, 0);
            dashboardBody.innerHTML += `<tr><td>Total Conflicts Defined</td><td>${conflictCount}</td></tr>`;

            const loadOverview = {};
            Object.keys(artistDict).forEach(artist => {
                loadOverview[artist] = artistDict[artist].assignedRoles.length;
            });
            dashboardBody.innerHTML += `<tr><td>Load Overview</td><td>${JSON.stringify(loadOverview)}</td></tr>`;
        }

        // Toggle dark mode
        function toggleDarkMode() {
            const mode = document.getElementById('darkModeToggle').value;
            document.body.classList.toggle('dark-mode', mode === 'dark');
            localStorage.setItem('darkMode', mode);
        }

        // Global artistDict for dashboard access
        let artistDict = {};
    </script>
</body>
</html>
